<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Celmec</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="the-celmec-book.html"><strong aria-hidden="true">1.</strong> The Celmec Book</a></li><li class="chapter-item expanded "><a href="getting-the-celmec-library.html"><strong aria-hidden="true">2.</strong> Getting the Celmec Library</a></li><li class="chapter-item expanded "><a href="two-body-problem.html"><strong aria-hidden="true">3.</strong> Two Body Problem</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="two-body-problem-necessary-concepts.html"><strong aria-hidden="true">3.1.</strong> Two Body Problem: Necessary Concepts</a></li><li class="chapter-item expanded "><a href="two-body-problem-simulation.html"><strong aria-hidden="true">3.2.</strong> Two Body Problem: Simulation</a></li><li class="chapter-item expanded "><a href="two-body-problem-the-underlying-physics.html"><strong aria-hidden="true">3.3.</strong> Two Body Problem: The Underlying Physics</a></li><li class="chapter-item expanded "><a href="two-body-problem-a-look-inside-the-functions-used-in-the-simulation.html"><strong aria-hidden="true">3.4.</strong> Two-body Problem: A Look Inside the Functions Used in the Simulation</a></li><li class="chapter-item expanded "><a href="two-body-problem-hyperbolic-and-parabolic-orbits.html"><strong aria-hidden="true">3.5.</strong> Two-body Problem: Hyperbolic and Parabolic Orbits</a></li></ol></li><li class="chapter-item expanded "><a href="keplerian-elements.html"><strong aria-hidden="true">4.</strong> Keplerian Elements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="keplerian-elements-simulation.html"><strong aria-hidden="true">4.1.</strong> Keplerian Elements: Simulation</a></li><li class="chapter-item expanded "><a href="keplerian-elements-parabolic-orbit.html"><strong aria-hidden="true">4.2.</strong> Keplerian Elements: Parabolic Orbit</a></li><li class="chapter-item expanded "><a href="keplerian-elements-coordinate-transformation.html"><strong aria-hidden="true">4.3.</strong> Keplerian Elements: Coordinate Transformation</a></li><li class="chapter-item expanded "><a href="keplerian-elements-a-look-inside-the-transformation.html"><strong aria-hidden="true">4.4.</strong> Keplerian Elements: A Look Inside the Transformation</a></li></ol></li><li class="chapter-item expanded "><a href="system.html"><strong aria-hidden="true">5.</strong> System: A celmec Data Structure</a></li><li class="chapter-item expanded "><a href="impulse.html"><strong aria-hidden="true">6.</strong> Impulse</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="impulse-implementation-details.html"><strong aria-hidden="true">6.1.</strong> Impulse: Implementation Details</a></li></ol></li><li class="chapter-item expanded "><a href="glossary_of_terms.html"><strong aria-hidden="true">7.</strong> Glossary of Terms</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Celmec</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-celmec-book---or-learning-elementary-celectial-mechanics-via-coding"><a class="header" href="#the-celmec-book---or-learning-elementary-celectial-mechanics-via-coding">The Celmec Book - or learning elementary celectial mechanics via coding</a></h1>
<p>This a book that want's to be 2 things at once:</p>
<ol>
<li>An introduction to elementary celestial mechanics.</li>
<li>An guide to the <code>celmec</code> Rust library for celestial mechanics.</li>
</ol>
<p>I'll try to write it so that no pre-requisite knowledge of celestial mechanics is necessary. Some knowledge of basic programming, Rust, Python (especially <code>matplotlib</code>) and vector algebra is needed, though.</p>
<p>After instructions on how to make the <code>celmec</code> library available for you, each chapter introduces a little simulation with visualization with Python. The chapters start with a section  about some necessary physics to understand the simulation, the simulation itself as well as its results and then some additional physics which can be seen working in the simulation results. The physics sections will mainly provide ready formulas that other people have proved/calculated from lower principles, but for those interested, there will be references to other texts.</p>
<p>Currently <code>celmec</code> covers only the <em>two-body problem</em> ie. how to bodies move with gravity acting between them, but I'll attempt to extend the library (and then this book) in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-the-celmec-library"><a class="header" href="#getting-the-celmec-library">Getting the Celmec Library</a></h1>
<p><code>Celmec</code> is Rust library and can be made available by adding it to your Rust project's <code>Cargo.toml</code>. To get the necessary info about what <code>Cargo.toml</code> is read <a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">this</a> and <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html">this</a> section from the &quot;The Rust Programming Language&quot; -book.</p>
<p>To use <code>celmec</code> you need to add this to your project's <code>Cargo.toml</code> under <code>[dependencies]</code>:</p>
<pre><code>celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
</code></pre>
<p>Celmec uses <code>ndarray</code> for vector algebra, so you also need to add that library to your <code>Cargo.toml</code>. The examples in this book point out which version of <code>ndarray</code> was used for them. I'll try to make it so that the examples would work with the latest version, but given that this a free-time project, I will be checking if newer version work only sporadically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem"><a class="header" href="#two-body-problem">Two Body Problem</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem-necessary-concepts"><a class="header" href="#two-body-problem-necessary-concepts">Two Body Problem: Necessary concepts</a></h1>
<p>Before using <code>celmec</code> for simulations, a bare minimum of celestial mechanics concepts are needed. Those familiar with the topic can jump to <a href="two-body-problem-simulation.html">the next sub-chapter</a> which deals with writing a first simulation.</p>
<p><code>celmec</code> solves the two-body problem using Newtonian gravitation: a mathematical model to describe the motion of planets around the sun (and all other bodies gravitationally acting with each other for that matter). The following uses results and properties from that model which match the observed reality fairly well for the contents of this chapter. It is good to bear in mind that the Newtonian model for gravity does not hold in all situations and that for the examples to come, simplifications about reality have been done.</p>
<p>Due to the force of gravity the planets around the sun on trajectories that are ellipses, with the sun in on of the foci of the ellipse. The foci are 2 such points inside the ellipse that the sum of the radii from each of them to a point on the ellipse is a constant. In the picture the balck dots are the foci, a and b the radii and a+b is constant:</p>
<p align="center">
  <img src="images/foci.png" />
  <figcaption>Foci of an ellipse: the black dots are the foci, a+b is constant</figcaption>
</p>
<p>If the focii are close to one another, the ellipse becomes a circle. As they become further apart, the ellipse becomes more &quot;elongated&quot;. A measure of this elongation is called eccentricity which ranges from 0 for a circle and gets closer and closer to 1 as the focii become infinetly far apart. The picture below shows some ellipses for different values of eccentricity, 0, 0.7 and 0.99, respectively:</p>
<p align="center">
  <img src="images/ellipse-eccentricities.png" />
  <figcaption>Ellipses of eccentricities 0 (circle), 0.7 and 0.99</figcaption>
</p>
<p>The shape, size and motion of a planet along the elliptic orbit can be determined from 3 things:</p>
<ol>
<li>The gravitational parameter \( \mu \) which is the sum of the masses of the sun and the planet multiplied by an observational constant called the gravitational constant \( G \). The equation for \( \mu \) is then: \( \mu = G(m_{planet} + m_{sun}) \)</li>
<li>One observed position of the planet with respect to the sun</li>
<li>The observed speed of the planet with respect to the sun when it is at he position from the previous point</li>
</ol>
<p>With this knowledge in mind, we can throw ourselves into our first simulation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem-simulation"><a class="header" href="#two-body-problem-simulation">Two Body Problem: Simulation</a></h1>
<p>As a first simulation with <code>celmec</code>, we'll simulate one round of Mercury around the sun as a two body problem. We'll first walk through building the simulation, but the final Rust code can be found further down.</p>
<h2 id="walking-through-the-writing-of-the-simulation"><a class="header" href="#walking-through-the-writing-of-the-simulation">Walking through the writing of the simulation</a></h2>
<p>First init a new Rust project called <code>two-body-problem</code>:</p>
<pre><code>cargo init two-body-problem
</code></pre>
<p>Edit the project's <code>Cargo.toml</code> by adding the following under <code>[dependencies]</code>:</p>
<pre><code>ndarray = &quot;0.15.6&quot; #Or choose your preferred version
celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
</code></pre>
<p>Then we can start editing the project's <code>src/main.rs</code>. First, remove the default content and import the following from <code>ndarray</code> </p>
<pre><code>use ndarray::{Array, Array1}
</code></pre>
<p>Then import the following from celmec:</p>
<pre><code>use celmec::{orbit, orbital_elements};
</code></pre>
<p>The <code>orbit</code> module contains functions functions for the simulation and the <code>orbital_elements</code> module has functions to calculate certain properties of the orbit without simulating its time-evolution.</p>
<p>Next, we need the masses of Mercury and the sun and some initial conditions for the position and velocity of the planet with respect to the sun. Sun's mass is (the googlable) 1.989 * 10<sup>30</sup>kg and the mass of Mercury (along other info about the planet that will be used), namely 3.3010 * 10<sup>23</sup> kg, can be found from <a href="https://nssdc.gsfc.nasa.gov/planetary/factsheet/mercuryfact.html">Nasa's fact sheet</a>. To have some simple initial conditions, let's have Mercury furthest away from the sun it reaches (ie. Mercury's aphelion) and let's fix our coordinates so that this point is to the direction of the negative x-axis. The distance of Mercury from the sun in the aphelion is 69.818 * 10<sup>9</sup> m. According to Kepler's third law, Mercury's orbital velocity is the slowest at aphelion. That slowest speed is 38.86 * 10<sup>3</sup> m/s and that is in the direction of the negative y-axis. Let's decide, for convenience, that is the to the direction of the negativee y-axis. As a small spoiler, choosing to start with negative values will align our xy-plane nicely with the choice of polar coordinates that will be done later. Now we write all this into the <code>main</code> function of our project:</p>
<pre><code>    let mu: f64 = orbit::calculate_mu(3.301e23, 1.989e30);
    let rr: Array1&lt;f64&gt; = array![-69.818e9, 0., 0.];
    let vv: Array1&lt;f64&gt; = array![0., -38.86e3, 0.];
</code></pre>
<p>Before using these values for the simulation, let's first check a key quantity of the system from them: the eccentricity <code>e</code>:</p>
<pre><code>    let e: f64 = orbital_elements::calculate_e(rr.clone(), vv.clone(), mu);
    println!(&quot;Eccentricity: {}&quot;, e);
</code></pre>
<p>Then we need some info about how long and how finely we want to simulate:</p>
<pre><code>    let steps: usize = 100;
    let simulation_time: f64 = 7603200.;
</code></pre>
<p>The <code>steps</code> is the number of point we want to have results for and <code>simulation_time</code> is the sideral orbit period from the fact sheet above converted to seconds (so * 24 h/d * 60 min/h * 60 s/min). Then we can calculate the true anomaly <code>f</code> for our simulation period using <code>celmec</code>:</p>
<pre><code>    let f: Array1&lt;f64&gt; = orbit::calculate_f_from_initial_rr_and_vv(
        rr.clone(),
        vv.clone(),
        mu,
        simulation_time,
        steps,
    );

</code></pre>
<p>Despite starting with xy-coordinates, let's switch to polar coordinates as they are somewhat more convenient for orbits. We chose the orbital plane as our xy-plane and in that plane <code>f</code> will serve as the angle for polar coordinates in that plane. But we still need radii corresponding to the values of <code>f</code> we obtained above. For that, we need the semi-major axis <code>a</code> of the system and can then proceed to calculate the radius:</p>
<pre><code>    let a: f64 = orbit::calculate_a_from_initial_rr_and_vv(rr, vv, mu);
    let radius: Array1&lt;f64&gt; = orbit::calculate_radius_from_f(f.clone(), e, a);
</code></pre>
<p>Let's then print some values from our simulation as checks:</p>
<pre><code>    println!(
        &quot;Maximum distance from the sun (aphelion): {}&quot;,
        radius.iter().max_by(|a, b| a.total_cmp(b)).unwrap()
    );
    println!(
        &quot;Minimum distance from the sun (perihelion): {}&quot;,
        radius.iter().min_by(|a, b| a.total_cmp(b)).unwrap()
    );
</code></pre>
<p>And then write the results into a file. First some imports to the beginning of our <code>main.rs</code>:</p>
<pre><code>use std::fs::File;
use std::io::Write;
</code></pre>
<p>And then the actual writing inside the main function:</p>
<pre><code>    let mut coordinate_file = File::create(&quot;mercury.csv&quot;).unwrap();
    write!(coordinate_file, &quot;radius,f\n&quot;).unwrap();
    for i in 0..=(steps - 1) {
        write!(coordinate_file, &quot;{},{}\n&quot;, radius[i], f[i]).unwrap();
    }
</code></pre>
<h2 id="final-rust-code"><a class="header" href="#final-rust-code">Final Rust code</a></h2>
<p><code>Cargo.toml</code>:</p>
<pre><code>[package]
name = &quot;two-body-problem&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
ndarray = &quot;0.15.6&quot;
celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
</code></pre>
<p><code>main.rs</code>:</p>
<pre><code>use celmec::{orbit, orbital_elements};
use ndarray::{array, Array1};
use std::fs::File;
use std::io::Write;

fn main() {
    let mu: f64 = orbit::calculate_mu(3.301e23, 1.989e30);
    let rr: Array1&lt;f64&gt; = array![-69.818e9, 0., 0.];
    let vv: Array1&lt;f64&gt; = array![0., -38.86e3, 0.];

    let e: f64 = orbital_elements::calculate_e(rr.clone(), vv.clone(), mu);
    println!(&quot;Eccentricity: {}&quot;, e);

    let steps: usize = 100;
    let simulation_time: f64 = 7603200.;

    let f: Array1&lt;f64&gt; = orbit::calculate_f_from_initial_rr_and_vv(
        rr.clone(),
        vv.clone(),
        mu,
        simulation_time,
        steps,
    );

    let a: f64 = orbit::calculate_a_from_initial_rr_and_vv(rr, vv, mu);
    let radius: Array1&lt;f64&gt; = orbit::calculate_radius_from_f(f.clone(), e, a);

    println!(
        &quot;Maximum distance from the sun (aphelion): {}&quot;,
        radius.iter().max_by(|a, b| a.total_cmp(b)).unwrap()
    );
    println!(
        &quot;Minimum distance from the sun (perihelion): {}&quot;,
        radius.iter().min_by(|a, b| a.total_cmp(b)).unwrap()
    );

    let mut coordinate_file = File::create(&quot;mercury.csv&quot;).unwrap();
    write!(coordinate_file, &quot;radius,f\n&quot;).unwrap();
    for i in 0..=(steps - 1) {
        write!(coordinate_file, &quot;{},{}\n&quot;, radius[i], f[i]).unwrap();
    }
}
</code></pre>
<h2 id="visualising-the-results"><a class="header" href="#visualising-the-results">Visualising the results</a></h2>
<p>To visualise the results, the following bit of Python code can be used. Have Python and the necessary libraries installed, and then run the script inside the base directory of the cargo project with:</p>
<pre><code>python plot_two_body_orbit.py
</code></pre>
<p>The script itself:</p>
<pre><code>#!/usr/bin/python

import pandas as pd
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;mercury.csv&quot;)

def plot_2d_orbit(i):
    plt.polar(df.f[0:i], df.radius[0:i], 'k.')

def main():
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn, polar=True)
    ax.set_rlim(rmin=0, rmax=7e10)
    anim = FuncAnimation(fig, plot_2d_orbit, frames=100, repeat=True)
    
    f = r&quot;mercury.gif&quot;
    writergif = PillowWriter(fps=20)
    anim.save(f, writer=writergif)

    plt.show()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
<h2 id="a-look-at-the-results"><a class="header" href="#a-look-at-the-results">A look at the results</a></h2>
<p>The Python script should produce a plot with the all the points at different times plotted at once and an animated gif of the time evolution of the orbit. Let's look at the final plot first:</p>
<p><img src="images/mercury.png" alt="Mercury's orbit" /></p>
<p>We have a fairly circular orbit around the origin, which is indeed how a planet's orbit around the sun should look like. By looking carefully, we see that that the orbit is not quite a circle, but stratches further away from the origin on the left. In fact, the orbit should be an ellipsis in fact, but that is perhaps a bit hard to tell with naked eye (at least for the author).</p>
<p>Then, there is the animation:</p>
<details>
  <summary>Mercury's orbit animated</summary>
<p><img src="images/mercury.gif" alt="Mercury's orbit animated" /></p>
</details>
<p>Looking at the animation, we see it starting from the aphelion in the left as expected given our choice of the initial coordinates. One full orbit is then completed. Because true anomaly is measured from perihelion and matplolib sets the zero angle to the direction of the positive x-axis, we picked our initial position and velocity in the way we did so they would align with the final polar view we are using.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem-the-underlying-physics"><a class="header" href="#two-body-problem-the-underlying-physics">Two-Body Problem: The Underlying Physics</a></h1>
<p>To understand the way <code>celmec</code> calculates the true anomaly, definitions for two additional anomalies are needed. Firstly, mean anomaly \( M \) would be the angle from the perihelion if a planet were orbiting the sun on a circular orbit with constant speed. Secondly, eccentric anomaly \( E \) is defined as the image below:</p>
<p align="center">
  <img src="images/eccentric-anomaly.png" />
  <figcaption>Geometric definition of eccentric anomaly</figcaption>
</p>
<p>It can be shown, that these two anomalies are related by the Kepler equation:</p>
<p>\[ M = E - e \sin(E) \]</p>
<p>where:</p>
<p>\[ M = \textrm{ mean anomaly } \]
\[ E = \textrm{ eccentric anomaly } \]
\[ e = \textrm{ eccentricity } \]</p>
<p>The eccentric anomaly is then related to true anomaly by:</p>
<p>\[ f = \arccos( \frac{\cos(E) - e}{1 - e \cos(E)} ) \]</p>
<p><code>celmec</code> solves the Kepler equation for \( E \) using the <a href="https://en.wikipedia.org/wiki/Newton%27s_method">Newton-Raphson method</a> for:</p>
<p>\[ 0 = E - e \sin(E) - M \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem-a-look-inside-the-functions-used-in-the-simulation"><a class="header" href="#two-body-problem-a-look-inside-the-functions-used-in-the-simulation">Two-body Problem: A Look Inside the Functions Used in the Simulation</a></h1>
<p>To see all the physics and maths described in the previous subchapter to actually take place, one can look inside the function <code>orbit::calculate_f_from_initial_rr_and_vv</code>. It looks like this:</p>
<pre><code>pub fn calculate_f_from_initial_rr_and_vv(
    rr: Array1&lt;f64&gt;,
    vv: Array1&lt;f64&gt;,
    mu: f64,
    start_time: f64,
    end_time: f64,
    steps: usize,
) -&gt; Array1&lt;f64&gt; {
    let ee: Array1&lt;f64&gt; = calculate_ee(rr.clone(), vv.clone(), mu);
    let e: f64 = calculate_e(rr.clone(), vv.clone(), mu);
    let initial_f: f64 = calculate_initial_f_from_initial_conditions(rr.clone(), ee, e);
    let initial_eccentric_anomaly: Array1&lt;f64&gt; =
        calculate_eccentric_anomaly_from_f(array![initial_f], e);
    let a: f64 = calculate_a_from_initial_rr_and_vv(rr, vv, mu);
    let n: f64 = calculate_n(mu, a);
    let tau: f64 = calculate_tau(
        0.,
        calculate_mean_anomaly_from_eccentric_anomaly(initial_eccentric_anomaly, e)[0],
        n,
    );

    let t: Array1&lt;f64&gt; = Array1::linspace(start_time, end_time, steps);
    let eccentric_anomaly: Array1&lt;f64&gt; = calculate_eccentric_anomaly_iteratively(
        t.clone(),
        Array1::zeros(steps),
        0.0001,
        100,
        n,
        e,
        tau,
    );
    calculate_f_from_eccentric_anomaly(eccentric_anomaly, e)
}
</code></pre>
<p>Let's break that down:</p>
<ol>
<li><code>ee</code> is a vector is calculated with <code>calculate_ee</code>. Its length gives the eccentricity <code>e</code>, calculated by <code>calculate_e</code>.</li>
<li>True anomaly <code>f</code> at the initial vector position <code>rr</code> is calculated in <code>calculate_initial_f_from_initial_conditions</code> as it is needed for...</li>
<li>..initial eccentric anomaly calculated in <code>calculate_eccentric_anomaly_from_f</code> which in turn is needed for...</li>
<li><code>tau</code>, the time at which the planet finds itself at the perihelion, nearest to the sun, calculated in <code>calculate_tau</code>.</li>
<li>An additional quantity is needed to obtain <code>tau</code>. It's called <code>n</code> and is calculated in <code>calculate_n</code>.</li>
<li>Then an array <code>t</code> for all the time points in the simulation is initialized.</li>
<li>Next is the &quot;big thing&quot; of the simulation when eccentric anomaly is calculated for all simulation time points ie. for the array <code>t</code> in <code>calculate_eccentric_anomaly_iteratively</code>.</li>
<li>Finally we obtain true anomalies <code>f</code> from the previously obtained eccentric anomalies in <code>calculate_f_from_eccentric_anomaly</code> and return that.</li>
</ol>
<p>All of the above are part of the <code>orbit</code> module of <code>celmec</code> and one could drill down further into each of the above to see what they actually do, but to keep it short(ish), I'll just show here that <code>calculate_eccentric_anomaly_iteratively</code> is where the Newton-Raphson method gets applied like this:</p>
<pre><code>pub fn calculate_eccentric_anomaly_iteratively(
    t: Array1&lt;f64&gt;,
    initial_value: Array1&lt;f64&gt;,
    tolerance: f64,
    max_iterations: usize,
    n: f64,
    e: f64,
    tau: f64,
) -&gt; Array1&lt;f64&gt; {
    let parameters: HashMap&lt;&amp;str, f64&gt; = HashMap::from([(&quot;n&quot;, n), (&quot;e&quot;, e), (&quot;tau&quot;, tau)]);
    if e &gt; 1. {
        solve_equation_iteratively(
            &amp;hyperbolic_kepler_eq_iterative_step,
            initial_value,
            t,
            parameters,
            tolerance,
            max_iterations,
        )
    } else if e == 1. {
        solve_equation_iteratively(
            &amp;barker_eq_iterative_step,
            initial_value,
            t,
            parameters,
            tolerance,
            max_iterations,
        )
    } else if (e &lt; 1.) &amp;&amp; (e &gt;= 0.) {
        solve_equation_iteratively(
            &amp;kepler_eq_iterative_step,
            initial_value,
            t,
            parameters,
            tolerance,
            max_iterations,
        )
    } else {
        panic!(&quot;Eccentricity cannot be negative.&quot;);
    }
}
</code></pre>
<p>I'll not go through that function step by step but instead use it to bring up two points. Firstly, note that there is some equation solving happening for <code>e</code> (eccentricity) values of 1 and above. Eccentricity of ellipses is always between 0 and 1 (with 0 included and 1 not). So what does it mean for an orbit to have an eccentricity of 1 or above? It turn out not all orbits are closed ellipses but they can also take the form of a parabola (eccentricity 1) ot a byperbola (eccentricity above 1). These orbits will be the subject of the next subchapter so stay tuned.</p>
<p>But first the second point: in the <code>calculate_eccentric_anomaly_iteratively</code> function the last word in its name, <code>iteratively</code>, might give a hint that there are other ways to calculate the eccentric anomaly instead of Newton-Raphson. And indeed, one could use a series expansion (if one is familiar with such things) by using <code>calculate_f_from_series</code>. Note though, that it currently contains so few terms that it gives something even remotely reliable only for near-circle orbit ie. orbits with eccentricity close to 0.</p>
<p>All the functions described above are public, so they can be used in whatever you might fancy to try with <code>celmec</code>. To see the full technical Rust documentation of the library you can either:</p>
<ol>
<li>Git clone <a href="https://github.com/juuso22/celmec.git">the <code>celmec</code> repo</a> and run <code>cargo doc</code> inside it if you are familiar with git. The output of <code>cargo doc</code> should tell you where to look next.</li>
<li>Navigate to URL_HERE to see the same docs.</li>
</ol>
<p>Further in this book, we'll tear some other used functions open in case the author has deemed them to have eaten things of interest. This is done to help out with navigating the the technical Rust documentation as I find those sometimes intimidating to tacḱle head on and want to ease the burden for anyone else feeling similarly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-body-problem-hyperbolic-and-parabolic-orbits"><a class="header" href="#two-body-problem-hyperbolic-and-parabolic-orbits">Two-body problem: Hyperbolic and Parabolic Orbits</a></h1>
<p>Instead of a closed, elliptic orbit like Mercury's objects can also just fly past each other. This happens when we have:</p>
<p>\[ e \ge 1 \]</p>
<p>The \( e &gt; 1 \) case corresponds to a hyperbole-shaped orbit and the \( e = 1 \) case to a parabola and after some algebra the replacement for Kepler equation for these two cases becomes:</p>
<p>\[ n(t-\tau) = e\sinh{E} - E, \textrm{ when } e \gt 0 \]</p>
<p>\[ n(t-\tau) = \frac{E^3}{6}+\frac{E}{2}, \textrm{ when } e = 0 \]</p>
<p>Where the quantity \( n \) cannot geometrically be understood as in the elliptic case, but obeys the formula:</p>
<p>\[ n = \sqrt{\mu}a^\frac{-3}{2} \]</p>
<p>In case of an eccentricity greater or equal to 1, <code>celmec</code> solves these equations instead of the Kepler equation.</p>
<h2 id="simulating-a-hyperbolic-orbit"><a class="header" href="#simulating-a-hyperbolic-orbit">Simulating a hyperbolic orbit</a></h2>
<p>To simulate a hyperbolic orbit, we can use the Mercury example, but give the nearest planet the following initial conditions:</p>
<pre><code>    let rr: Array1&lt;f64&gt; = array![-3e11, 0., 0.];
    let vv: Array1&lt;f64&gt; = array![-6e4, -1e4, 0.];
</code></pre>
<p>The plotting script also needs a small scaling adjustment then:</p>
<pre><code>    ax.set_rlim(rmin=0, rmax=3.1e11)
</code></pre>
<p>and rerunning the simulation we should end up with the following:</p>
<p><img src="images/flyby-mercury.png" alt="&quot;Flyby Mercury's&quot; orbit" /></p>
<p>and the same animated:</p>
<details>
  <summary>"Flyby Mercury's" orbit animated</summary>
<p><img src="images/flyby-mercury.gif" alt="&quot;Flyby Mercury's&quot; orbit animated" /></p>
</details>
<p>You can try playing around with different initial conditions, simulation times and object masses to see what kind of orbits you'll get!</p>
<h2 id="parabolic-orbit-simulation"><a class="header" href="#parabolic-orbit-simulation">Parabolic orbit simulation</a></h2>
<p>As it's a bit tedious to construct a combination of initial conditions and masses that would result in an eccentricity of exactly 1, it would be handy if we could start by telling <code>celmec</code> to simulate using a given <code>e</code>. Here is where it's time to change chapters and talk about orbital elements which will enable us to do just that.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keplerian-elements"><a class="header" href="#keplerian-elements">Keplerian Elements</a></h1>
<p>Instead of starting with a known initial position and velocity of a planet it is also possible to have collected a collection of the properties of the orbit and to calculate the time-evolution of the planet along the orbit using those. One set of such properties are called the Keplerian elements and what they are is <a href="https://en.wikipedia.org/wiki/Orbital_elements#Keplerian_elements">described in Wikipedia</a> with an especially helpful picture attached at the time of the writing.</p>
<p>In a nutshell, the Keplerian elements as used by <code>celmec</code> consist of quantities that describe:</p>
<ol>
<li>How the plane of the orbit of the planet (or other object of interest) is positioned vis-à-vis the ecliptica ie. the plane on which the erath orbits the sun. These quantities are the angle between the orbital plane of the object being studied and ecliptica: inclination (<code>iota</code>) and the angle at which the orbit rises from below above to ecliptica with respect to a fixed direction (spring equinox): longitude of the ascending node (<code>longitude_of_the_ascending_node</code>).</li>
<li>How the orbit is shaped ie. its eccentricity <code>e</code> and semi-major axis <code>a</code>.</li>
<li>The angle from longitude of the ascending node to the perihelion along the orbital plane: argument of perihelion (<code>omega</code>)</li>
<li>A time at which the object passes its perihelion <code>tau</code>. Note that if you read the Wikipedia article, this differs slightly from the &quot;true anomaly at t<sub>0</sub>&quot;: <code>tau</code> is equal to that t<sub>0</sub> when true anomaly is 0.</li>
</ol>
<p>Next a little simulation using the Keplerian elements. And the reason I moved from talking about the orbit of a planet to the orbit of an object is because the simulation target won't be a planet, but a comet instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keplerian-elements-simulation"><a class="header" href="#keplerian-elements-simulation">Keplerian Elements: Simulation</a></h1>
<p>To demonstrate the use of Keplerian elements, let's calculate the orbit of <a href="https://en.wikipedia.org/wiki/Halley%27s_Comet">Halley's comet</a>. I have stolen the Keplerian elements from Wikipedia.</p>
<h2 id="walking-through-the-writing-of-the-simulation-1"><a class="header" href="#walking-through-the-writing-of-the-simulation-1">Walking through the writing of the simulation</a></h2>
<p>First init a new rust project called <code>halleys-comet</code>:</p>
<pre><code>cargo init halleys-comet
</code></pre>
<p>Edit the project's <code>Cargo.toml</code> by adding the following under <code>[dependencies]</code>:</p>
<pre><code>celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
ndarray = &quot;0.15.6&quot; #Or choose your preferred version
</code></pre>
<p>Then we can start editing the project's <code>src/main.rs</code>. First, remove the default content and import the following from <code>ndarray</code> </p>
<pre><code>use ndarray::{Array, Array1}
</code></pre>
<p>Then import the following from celmec:</p>
<pre><code>use celmec::orbital_elements
</code></pre>
<p>The <code>orbital_elements</code> module contains a sturct called <code>KeplerianElements</code> which will contain the Keplerian elements of the body we want to simulate. The following abbreviations for the elements are used (for a full list of all abbreviations used in celmec see <a href="./glossary_of_terms.html">Glossary of Terms</a>):</p>
<pre><code>a - semi-major axis
e - eccentricity
iota - inclination
tau - perihelion time
omega - argument of periapsis
</code></pre>
<p>In our main function, let's create an instance of <code>KeplerianElements</code> for Halleys' comet:</p>
<pre><code>    let halleys_keplerian_elements = orbital_elements::KeplerianElements {
        e: 0.96658,
        longitude_of_the_ascending_node: 1.03665,
        tau: 0.,
        a: 2.65342e12,
        iota: 2.82673,
        omega: 1.95564,
    };
</code></pre>
<p>Everything is in SI units and the perihelion time is set to zero for simplicity.</p>
<p>Next, we need some mote imports from celmec to actually calculate something using the orbital elements:</p>
<pre><code>use celmec::{orbit, orbital_elements};
</code></pre>
<p>The <code>orbit</code> module has functions to calculate properties of the orbit and/or time evolution of various quantities. We'll first calculate the time evolution of true anomaly (denoted <code>f</code>) from the Keplerian elemnts. We'll cheat a little and choose the time interval for which calculate from <code>tau</code> to <code>tau</code> + the time of one rotation of the comet around the sun to see a nice full ellipsis. The time of the rotation we look up again from Wikipedia and convert it to seconds:</p>
<pre><code>    let ticks = 200;
    let rotation_time = 2379801600.;
    let time: Array1&lt;f64&gt; = Array::linspace(halleys_keplerian_elements.tau, halleys_keplerian_elements.tau + rotation_time, ticks);
    let f: Array1&lt;f64&gt; = orbit::calculate_f_from_series(
        time.clone(),
        halleys_keplerian_elements.e,
        rotation_time,
        halleys_keplerian_elements.tau,
    );
</code></pre>
<p>Here series refers to the Fourier series. The array <code>f</code> represents the true anomaly at each point of time we are calculating for.</p>
<p>From true anomaly and the Keplerian elemnts, polar coordinates (with Sun at the origin) be calculated over our chosen time interval <code>time</code>. First we need to add another import, though:</p>
<pre><code>use celmec::{orbit, orbital_elements, transformations};
</code></pre>
<p>Then we can calculate:</p>
<pre><code>    let radius = orbit::calculate_radius_from_f(
        f.clone(),
        halleys_keplerian_elements.e,
        halleys_keplerian_elements.a,
    );
    let polar_angle = transformations::polar_angle_from_keplerian_elements(
        f.clone(),
        halleys_keplerian_elements.iota,
        halleys_keplerian_elements.omega,
    );
</code></pre>
<p>Let's write the polar coordinates and time into a file. First some imports:</p>
<pre><code>use std::fs::File;
use std::io::Write;
</code></pre>
<p>Then the actual writing:</p>
<pre><code>    let mut coordinate_file = File::create(&quot;halleys_polar_coordinates.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,radius,polar_angle\n&quot;).unwrap();
    for i in 0..=(ticks - 1) {
        write!(
            coordinate_file,
            &quot;{},{},{}\n&quot;,
            time[i], radius[i], polar_angle[i]
        )
        .unwrap();
    }
</code></pre>
<h2 id="final-rust-code-1"><a class="header" href="#final-rust-code-1">Final rust code</a></h2>
<p><code>Cargo.toml</code>:</p>
<pre><code>[package]
name = &quot;halleys-comet&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
ndarray = &quot;0.15.6&quot;
celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
</code></pre>
<p><code>src/main.rs</code>:</p>
<pre><code>use celmec::{orbit, orbital_elements, transformations};
use ndarray::{Array, Array1};
use std::fs::File;
use std::io::Write;

fn main() {
    let halleys_keplerian_elements = orbital_elements::KeplerianElements {
        e: 0.96658,
        longitude_of_the_ascending_node: 1.03665,
        tau: 0.,
        a: 2.65342e12,
        iota: 2.82673,
        omega: 1.95564,
    };

    let ticks = 200;
    let rotation_time: f64 = 2379801600.;
    let time: Array1&lt;f64&gt; = Array::linspace(
        halleys_keplerian_elements.tau,
        halleys_keplerian_elements.tau + rotation_time,
        ticks,
    );
    let f: Array1&lt;f64&gt; = orbit::calculate_f_from_series(
        time.clone(),
        halleys_keplerian_elements.e,
        rotation_time,
        halleys_keplerian_elements.tau,
    );

    let radius = orbit::calculate_radius_from_f(
        f.clone(),
        halleys_keplerian_elements.e,
        halleys_keplerian_elements.a,
    );
    let polar_angle = transformations::polar_angle_from_keplerian_elements(
        f.clone(),
        halleys_keplerian_elements.iota,
        halleys_keplerian_elements.omega,
    );

    let mut coordinate_file = File::create(&quot;halleys_polar_coordinates.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,radius,polar_angle\n&quot;).unwrap();
    for i in 0..=(ticks - 1) {
        write!(
            coordinate_file,
            &quot;{},{},{}\n&quot;,
            time[i], radius[i], polar_angle[i]
        )
        .unwrap();
    }
}
</code></pre>
<h2 id="visualising-the-results-1"><a class="header" href="#visualising-the-results-1">Visualising the results</a></h2>
<p>To visualise the results, the following bit of Python code can be used. Have Python and the necessary libraries installed, and then run the script inside the base directory of the cargo project with:</p>
<pre><code>python plot_halleys_orbit.py
</code></pre>
<p>The script itself:</p>
<pre><code>import pandas as pd
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;halleys_orbit_2d.csv&quot;)

def plot_2d_orbit(i):
    plt.polar(df.f[0:i], df.radius[0:i], 'k.')

def main():
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn, polar=True)
    ax.set_rlim(rmin=0, rmax=6e12)    
    anim = FuncAnimation(fig, plot_2d_orbit, frames=50, repeat=True)
    
    f = r&quot;halley.gif&quot; 
    writergif = PillowWriter(fps=20)
    anim.save(f, writer=writergif)

    plt.show()

if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<h3 id="so-what-do-the-simulation-results-look-like"><a class="header" href="#so-what-do-the-simulation-results-look-like">So what do the simulation results look like</a></h3>
<p>The way the above python script is done, should save an animated gif, but print a graph where the position of the comet at all the chosen time points. That graph should look something like this:</p>
<p><img src="images/halley.png" alt="Halley's comet's orbit" /></p>
<p>The orbit look like an ellipse as it should. Moreover, it can be seen that the further from the middle (ie. the Sun) the comet is the closer the plotted orbit points are to each other. As the time between two consecutive points is constant, this means that the further the comet is from the Sun, the slower it moves. This is even clearer in the animation of the orbit:</p>
<details>
  <summary>Halley's comet's orbit animated</summary>
<p><img src="images/halley.gif" alt="Halley's comet's orbit animated" /></p>
</details>
<p>This is in fact what <em>Kepler's third law</em> tells us and to explain what that is all about, it's best to jump to the next physics chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keplerian-elements-parabolic-orbit"><a class="header" href="#keplerian-elements-parabolic-orbit">Keplerian Elements: Parabolic Orbit</a></h1>
<p>With Keplerian elements, creating a simulation for parabolic orbit becomes somewhat easier. Instead of trying to figure out a right position-velocity combination to get \( e = 1 \), we can just set the eccentricity to one. Let's do that for Halley's comet by changing the definition of the Keplerian elements from the previous simulation to the following:</p>
<pre><code>    let halleys_keplerian_elements = orbital_elements::KeplerianElements {
        e: 1., //This has now changed compared to the previous simulation
        longitude_of_the_ascending_node: 1.03666,
        tau: 0.,
        a: 2.65342e12,
        iota: 2.82674,
        omega: 1.95564,
    };

</code></pre>
<p>One further change is needed. As the orbit will now be parabolic, there is no longer a <code>rotation_time</code> which can be used to calculate the 5th argument in:</p>
<pre><code>    let eccentric_anomaly: Array1&lt;f64&gt; = orbit::calculate_eccentric_anomaly_iteratively(
        time.clone(),
        time.clone(),
        0.00001,
        100,
        2. * PI / rotation_time,
        halleys_keplerian_elements.e,
        halleys_keplerian_elements.tau,
    );
</code></pre>
<p>But that 5th argument is the quantity \(n\), which can alternatively be calculated from the formula:</p>
<p>\[ n = \sqrt{\mu}a^\frac{-3}{2}, \textrm{ where } \mu = G(m_1m_2) \]</p>
<p><code>celmec</code> in fact has functions to calculate bot \(n\) and \(\mu\). Let's first add a line somewhere before the calculation of the eccentric anomaly which calculates the latter. I'll be lazy and not look up any estimates for the mass of the comet but simply set \(m_1\) to the mass of the Sun and \(m_2=0\):</p>
<pre><code>    let mu: f64 = orbit::calculate_mu(1.989e30, 0.);

</code></pre>
<p>Then the 5th parameter in the calculation of the eccentric anomaly can be set as follows:</p>
<pre><code>    let eccentric_anomaly: Array1&lt;f64&gt; = orbit::calculate_eccentric_anomaly_iteratively(
        time.clone(),
        time.clone(),
        0.00001,
        100,
        orbit::calculate_n(mu, halleys_keplerian_elements.a),
        halleys_keplerian_elements.e,
        halleys_keplerian_elements.tau,
    );
</code></pre>
<p>When you run the simulation, Rust compiler will complain about unused import of the <code>PI</code> constant. You can get rid of that by commenting the line:</p>
<pre><code>use std::f64::consts::PI;
</code></pre>
<p>if you want to.</p>
<h2 id="simulation-results"><a class="header" href="#simulation-results">Simulation results</a></h2>
<p>Running the modified Rust coed and the plotter script should yield the following nice parabola:</p>
<p><img src="images/flyby-halley.png" alt="&quot;Flyby Halley's&quot; orbit" /></p>
<p>And the same thing animated:</p>
<details>
  <summary>"Flyby Halley's" orbit animated</summary>
<p><img src="images/flyby-halley.gif" alt="&quot;Flyby Halley's&quot; orbit animated" /></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keplerian-elements-coordinate-transformation"><a class="header" href="#keplerian-elements-coordinate-transformation">Keplerian Elements: Coordinate Transformation</a></h1>
<p>So far all the visualisations in this book have been restricted to the orbital plane of the system being simulated. However, the Keplerian elements contain a bunch of angles, which determine the the position of the orbit with respect to the orbital plane of the Earth. For 3d visuals, let us know use these angles to switch from the plane of the system to a three-dimensional volume where the Sun lies at origin and the xy-plane is the orbital plane of the earth and use cartesian coordinates there. In order to do that, we can copy the code from the original simulation of Halley's comet's orbit and add some pieces.</p>
<p>Firstly, in order to do the coordinate switch, we'll need the <code>transformations</code> module of <code>celmec</code> so we'll modify our imports as follows:</p>
<pre><code>use celmec::{orbit, orbital_elements, transformations};
</code></pre>
<p>Then, after calculating the radii and true anomalies, the new module can be used to perform the coordinate transformation:</p>
<pre><code>    let cartesian_coordinates: (Array1&lt;f64&gt;, Array1&lt;f64&gt;, Array1&lt;f64&gt;) =
        transformations::cartesian_coordinates_from_f_r_and_keplerian_elements(
            f.clone(),
            radius.clone(),
            halleys_keplerian_elements,
        );

</code></pre>
<p>Then the output file generation has to be adjusted as well. Instead of what we previously had, we'll use:</p>
<pre><code>    let mut coordinate_file = File::create(&quot;halleys_orbit_3d.csv&quot;).unwrap();
    write!(coordinate_file, &quot;x,y,z\n&quot;).unwrap();
    for i in 0..=(ticks - 1) {
        write!(
            coordinate_file,
            &quot;{},{},{}\n&quot;,
            cartesian_coordinates.0[i], cartesian_coordinates.1[i], cartesian_coordinates.2[i],
        )
        .unwrap();
    }
</code></pre>
<h3 id="the-final-rust-code"><a class="header" href="#the-final-rust-code">The Final Rust Code</a></h3>
<p>In the end, <code>Config.toml</code> should look like this:</p>
<pre><code>[package]
name = &quot;coordinate-transformation&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
ndarray = &quot;0.15.6&quot;
celmec = { git = &quot;https://github.com/juuso22/celmec.git&quot; }
</code></pre>
<p>and <code>main.rs</code> should look like this</p>
<pre><code>use celmec::{orbit, orbital_elements, transformations};
use ndarray::Array1;
use std::fs::File;
use std::io::Write;

fn main() {
    let halleys_keplerian_elements = orbital_elements::KeplerianElements {
        e: 0.96658,
        longitude_of_the_ascending_node: 1.03666,
        tau: 0.,
        a: 2.65342e12,
        iota: 2.82674,
        omega: 1.95564,
    };

    let ticks = 50;
    let rotation_time: f64 = 2379801600.;
    let mu: f64 = orbit::calculate_mu(1.989e30, 0.);
    let f: Array1&lt;f64&gt; = orbit::calculate_f_from_keplerian_elements(
        &amp;halleys_keplerian_elements,
        mu,
        halleys_keplerian_elements.tau - rotation_time / 2.,
        halleys_keplerian_elements.tau + rotation_time / 2.,
        ticks,
    );

    let radius = orbit::calculate_r_from_f(
        f.clone(),
        halleys_keplerian_elements.e,
        halleys_keplerian_elements.a,
    );

    let cartesian_coordinates: (Array1&lt;f64&gt;, Array1&lt;f64&gt;, Array1&lt;f64&gt;) =
        transformations::cartesian_coordinates_from_f_r_and_keplerian_elements(
            f.clone(),
            radius.clone(),
            halleys_keplerian_elements,
        );

    let mut coordinate_file = File::create(&quot;halleys_orbit_3d.csv&quot;).unwrap();
    write!(coordinate_file, &quot;x,y,z\n&quot;).unwrap();
    for i in 0..=(ticks - 1) {
        write!(
            coordinate_file,
            &quot;{},{},{}\n&quot;,
            cartesian_coordinates.0[i], cartesian_coordinates.1[i], cartesian_coordinates.2[i],
        )
        .unwrap();
    }
}
</code></pre>
<h3 id="visualising-the-results-2"><a class="header" href="#visualising-the-results-2">Visualising the results</a></h3>
<p>For the visualisation, the following python script can be used:</p>
<pre><code>import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;halleys_orbit_3d.csv&quot;)

def plot_3d_orbit(i):
    plt.plot(df.x[0:i], df.y[0:i], df.z[0:i], 'k.')

def main():
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn, projection='3d')
    ax.set_xlabel(&quot;x&quot;)
    ax.set_ylabel(&quot;y&quot;)
    ax.set_zlabel(&quot;z&quot;)
    ax.set_xlim([0, 1.1*np.max(df.x)])
    ax.set_ylim([1.1*np.min(df.y), 1.1*np.max(df.y)])
    ax.set_zlim([1.1*np.min(df.z), 0])
    anim = FuncAnimation(fig, plot_3d_orbit, frames=50, repeat=True)
    
    f = r&quot;halley_3d.gif&quot;
    writergif = PillowWriter(fps=20)
    anim.save(f, writer=writergif)

    plt.show()

if __name__ == &quot;__main__&quot;:
    main()

</code></pre>
<p>which can be run like this:</p>
<pre><code>python plot_halleys_3d_orbit.py
</code></pre>
<p>This should give an image like this:</p>
<p><img src="images/halley-3d.png" alt="Halley's 3d orbit" /></p>
<p>and the same animated:</p>
<details>
  <summary>Halley's 3d orbit animated</summary>
<p><img src="images/halley-3d.gif" alt="Halley's 3d orbit" /></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keplerian-elements-a-look-inside-the-transformation"><a class="header" href="#keplerian-elements-a-look-inside-the-transformation">Keplerian Elements: A Look Inside the Transformation</a></h1>
<p>To wrap up with Keplerian elements, let's have a look inside the coordinate transformation function <code>cartesian_coordinates_from_f_r_and_keplerian_elements</code>:</p>
<pre><code>pub fn cartesian_coordinates_from_f_r_and_keplerian_elements(
    f: Array1&lt;f64&gt;,
    r: Array1&lt;f64&gt;,
    keplerian_elements: orbital_elements::KeplerianElements,
) -&gt; (Array1&lt;f64&gt;, Array1&lt;f64&gt;, Array1&lt;f64&gt;) {
    let (theta, phi) = spherical_coordinates_from_f_and_keplerian_elements(f, keplerian_elements);
    cartesian_coordinates_from_spherical_coordinates(theta, phi, r)
}
</code></pre>
<p>There we see that to obtain the cartesinan coordinates, we actually go through spherical coordinates first. Let's dig deeper to see where those come from in <code>spherical_coordinates_from_f_and_keplerian_elements</code>:</p>
<pre><code>pub fn spherical_coordinates_from_f_and_keplerian_elements(
    f: Array1&lt;f64&gt;,
    keplerian_elements: orbital_elements::KeplerianElements,
) -&gt; (Array1&lt;f64&gt;, Array1&lt;f64&gt;) {
    let theta: Array1&lt;f64&gt; = theta_from_keplerian_elements(
        f.clone(),
        keplerian_elements.iota,
        keplerian_elements.omega,
        keplerian_elements.longitude_of_the_ascending_node,
    );
    let phi: Array1&lt;f64&gt; =
        phi_from_keplerian_elements(f, keplerian_elements.iota, keplerian_elements.omega);
    (theta, phi)
}
</code></pre>
<p>Here are separate functions for both spherical angle coordinates <code>theta</code> and <code>phi</code>. Both functions to obtain these cooedinates, <code>theta_from_keplerian_elements</code> and <code>phi_from_keplerian_elements</code>, are public for you to use as you please if using <code>celmec</code>. The technical Rust documentation will in turn provide details about the formulae used to calculate the angles: go check it out if you want to tear open the black box of maths used by <code>celmec</code>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-a-celmec-data-structure"><a class="header" href="#system-a-celmec-data-structure">System: A <code>celmec</code> Data Structure</a></h1>
<p>Before moving forward with the physics, I'll introduce the concept of a <code>System</code>. In <code>celmec</code>, a <code>System</code> is a celestial mechanics entity whose time-evolution can be simulated. As an example, the two bodies with one orbiting around the other as we have seen in this books so far is a system. In fact, such a <code>TwoBodySystem</code>  is currently the only available <code>System</code> in <code>celmec</code>. The concept of a <code>System</code> will, however, enable creation of further systems such as ones having more than two bodies or using a gravitational potential other than that of a sphere.</p>
<h2 id="making-a-simulation-using-a-twobodysystem"><a class="header" href="#making-a-simulation-using-a-twobodysystem">Making a Simulation using a <code>TwoBodySystem</code></a></h2>
<p>To simulate a <code>TwoBodySystem</code>, let's first create a new project with: <code>cargo init system</code>. Then we'll start crafting <code>systrem/src/main.rs</code>.</p>
<p>First we need some imports:</p>
<pre><code>use celmec::{system::System, two_body};
use ndarray::{array, Array1, Array2};
use std::fs::File;
use std::io::Write;
</code></pre>
<p>The first line imports the already familiar methods to manipulate a 2-body system and, with <code>system::System</code> the methods that any <code>System</code> has available.</p>
<p>Then, inside the <code>main</code> function, we shall wipe out the default &quot;Hello, world&quot; stuff and start by adding some information that will make up our <code>TwoBodySystem</code> to be:</p>
<pre><code>    let mu: f64 = two_body::calculate_mu(3.301e23, 1.989e30);
    let rr: Array1&lt;f64&gt; = array![-69.818e9, 0., 0.];
    let vv: Array1&lt;f64&gt; = array![0., -38.86e3, 0.];

    let end_time: f64 = 7603200.;

</code></pre>
<p>These are the same things that were allready used in our first 2-body simulation of Mercury.</p>
<p>Next we'll do something different though: create a <code>TwoBodySystem</code>:</p>
<pre><code>    let system: two_body::TwoBodySystem = two_body::create_two_body_system(0., end_time, 100, mu, rr, vv);
</code></pre>
<p>The inputs of the <code>create_two_body_system</code> are: starting time of the simulation, ending time of the simulation, number of simulated steps, the gravitational parameter, the initial position of the orbiting body with respect to the central body and the initial velocity of the orbiting body with respect to the central body. You can always also check the function out in the technical docs.</p>
<p>Any simulation of a <code>System</code> will output an array of arrays (<code>Array2&lt;f64&gt;</code>) where the rows are simulation results for all the simulation steps and a the columns represent time, x,y and coordinates and v<sub>x</sub>, v<sub>y</sub> and v<sub>z</sub> going from column number 0 upwards. For a <code>TwoBodySystem</code> the cartesian coordinated are with respect to a system where the xy-plane is defined as the plane against which inclination is measured and positive x-axis points into the direction from which longitude of the ascending node is measured. To get simulation result orbit, we do:</p>
<pre><code> let orbit: Array2&lt;f64&gt; = system.simulate();
</code></pre>
<p>And then write the simulation results in a file to be used for visualisations:</p>
<pre><code>    let mut coordinate_file = File::create(&quot;mercury.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,x,y,z,v_x,v_y,v_z\n&quot;).unwrap();
    for i in 0..orbit.dim().1 {
        write!(
            coordinate_file,
            &quot;{},{},{},{},{},{},{}\n&quot;,
            orbit[[0, i]],
            orbit[[1, i]],
            orbit[[2, i]],
            orbit[[3, i]],
            orbit[[4, i]],
            orbit[[5, i]],
            orbit[[6, i]]
        )
        .unwrap();
    }
</code></pre>
<details>
	<summary>The complete `main.rs`</summary>
<pre><code>use celmec::{system::System, two_body};
use ndarray::{array, Array1, Array2};
use std::fs::File;
use std::io::Write;

fn main() {
    let mu: f64 = two_body::calculate_mu(3.301e23, 1.989e30);
    let rr: Array1&lt;f64&gt; = array![-69.818e9, 0., 0.];
    let vv: Array1&lt;f64&gt; = array![0., -38.86e3, 0.];

    let end_time: f64 = 7603200.;

    let system: two_body::TwoBodySystem = two_body::create_two_body_system(0., end_time, 100, mu, rr, vv);

    let orbit: Array2&lt;f64&gt; = system.simulate();

    let mut coordinate_file = File::create(&quot;mercury.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,x,y,z,v_x,v_y,v_z\n&quot;).unwrap();
    for i in 0..orbit.dim().1 {
        write!(
            coordinate_file,
            &quot;{},{},{},{},{},{},{}\n&quot;,
            orbit[[0, i]],
            orbit[[1, i]],
            orbit[[2, i]],
            orbit[[3, i]],
            orbit[[4, i]],
            orbit[[5, i]],
            orbit[[6, i]]
        )
        .unwrap();
    }
}
</code></pre>
</details>
<h3 id="visualising-the-results-3"><a class="header" href="#visualising-the-results-3">Visualising the results</a></h3>
<p>In order to run the created Rust code, jump into its <code>system</code> project directory and run <code>cargo run</code>. To get some visuals out of the generated <code>mercury.csv</code> file, run the following python script with <code>python plot_system_orbit.py</code>: </p>
<details>
	<summary>Python script for orbit visualisation</summary>
<pre><code>import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;mercury.csv&quot;)

def main():    
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn)
    ax.set_xlim([1.1*np.min(df.x), 1.1*np.max(df.x)])
    ax.set_ylim([1.1*np.min(df.y), 1.1*np.max(df.y)])

    plt.plot(df.x, df.y, 'r.')
    plt.show()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</details>
<p>This should produce a familiar-looking ellipse from the first chapter:</p>
<p><img src="images/mercury-system.png" alt="Mercury orbit from system" /></p>
<p>Note that the initial conditions were chosen so that the orbit lies on the xy-plane. Hence the z-coordinate is 0 throughout.</p>
<h2 id="system-in-rust-terms"><a class="header" href="#system-in-rust-terms"><code>System</code> in Rust terms</a></h2>
<p>In Rust terms, <code>System</code> is actually a trait. That means roughly that it defines a collection of methods that any struct <em>implementing</em> that trait (such as <code>TwoBodySystem</code>) must define (or use the default definitions of the methods in the trait if they exist). <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">More on traits in the Rust book</a>. That means, that you can in fact implement your own <code>System</code> if you feel so inclined!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impulse"><a class="header" href="#impulse">Impulse</a></h1>
<p>What if we gave a body orbiting another a little push? Such a pushes are called impulses and they are handy to for eg. satellites to move them from one orbit to another.</p>
<p>In <code>celmec</code>, an impulse can be applied to a <code>System</code>. To make such a simulation, let's again create a new project <code>cargo init impulse</code>, navigate to <code>impulse/src/main.rs</code> adn add the required imports, which in this case are:</p>
<pre><code>use celmec::{impulse, two_body};
use ndarray::{array, Array1, Array2};
use std::f64::consts::PI;
use std::fs::File;
use std::io::Write;
</code></pre>
<p>So, in addition to the 2-body simulation module <code>two_body</code>, we now also import a module called <code>impulse</code>.</p>
<p>The let's start crafting a <code>main</code> function. We'll simulate a 500 kg satellite orbiting Earth, so let's first calculate the <code>mu</code> if that system:</p>
<pre><code>    let mu: f64 = two_body::calculate_mu(5.972e24, 5.0e3);
</code></pre>
<p>Then, let's have the satellite on a circular orbit at an altitude of 800 km. On a circular orbit, the semi-major axis <code>a</code> is equal to the radius of the orbit, which in turn is is the sum of the altitude and Earth's radius. We'll store the <code>a</code> on a variable for convenience further down the line:</p>
<pre><code>    let a: f64 = 8.0e5 + 6.378e6;
</code></pre>
<p>Next, also for later convenience, let's store the <em>period</em> of the circular orbit ie. how long it takes for the satellite to complete one rotation around the Earth. To that end, we can use the <code>calculate_period</code> method from the <code>two_body</code> module:</p>
<pre><code>    let period: f64 = two_body::calculate_period(mu, a);
</code></pre>
<p>Then it's time to crate a <code>System</code> from an initial position and velocity:</p>
<pre><code>    let rr0: Array1&lt;f64&gt; = array![a, 0., 0.];
    let vv0: Array1&lt;f64&gt; = array![0., 2. * a * PI / period, 0.];
    let system =
        two_body::create_two_body_system(0., 3. * period, 99, mu, rr0.clone(), vv0.clone());
</code></pre>
<p>The magnitude of the y-component of <code>vv0</code> is determined as follows: on a circular orbit, the speed of the satellite is constant (and I simply chose to have it in the positive y-direction at time 0) and that constant speed is the length of the orbit devided by the period. The length of the orbit is the circumference of the a spehere of radius <code>a</code>, so hence the <code>2. * a * PI</code> in the denominator.</p>
<p>Next, we'll define the impulse to be applied. Currently, an impulse in <code>celmec</code> is an array of changes in velocity at a given time points. That information is put in an <code>Array2&lt;f64&gt;</code> where the first row are the time points and the subsequent rows are the velocity changes's x, y, and z components, respectively. For our simple simulation, let's have a simplu velocity change (or delta-v or Δv) after one period:</p>
<pre><code>    let impulse: Array2&lt;f64&gt; = array![[period], [0.], [1.2e3], [0.]];
</code></pre>
<p>The impulse is in the direction of travel (ie. positive y-direction, check <code>vv0</code> which is the same as velocity after a full rotation) and I chose its magnitude (in m/s) by the scientific process of trying out a bunch of values and picking one that seemed to give a nice-looking result (the reader is encouraged to try their own values, more on that at the end of the chapter).</p>
<p>Then it's time to simulate: we'll now use the <code>impulse</code> module and its wrap-it-all function <code>calculate_impulse_effect</code>:</p>
<pre><code>    let orbit: Array2&lt;f64&gt; = impulse::calculate_impulse_effect(&amp;system.clone(), impulse);
</code></pre>
<p>The outputted <code>orbit</code> has the same format as the output of <code>simulate</code> on a <code>System</code> would have ie. the rows being time, x, y, z, v<sub>x</sub>, v<sub>y</sub> and v<sub>z</sub>, respectively, and columns representing those quantities for each time point of the simulation.</p>
<p>Finally, we'll write the orbit to a <code>.csv</code> file for some visualisations:</p>
<pre><code>    let mut coordinate_file = File::create(&quot;satellite.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,x,y,z,v_x,v_y,v_z\n&quot;).unwrap();
    for i in 0..orbit.dim().1 {
        write!(
            coordinate_file,
            &quot;{},{},{},{},{},{},{}\n&quot;,
            orbit[[0, i]],
            orbit[[1, i]],
            orbit[[2, i]],
            orbit[[3, i]],
            orbit[[4, i]],
            orbit[[5, i]],
            orbit[[6, i]]
        )
        .unwrap();
    }
</code></pre>
<details>
  <summary>The complete `main.rs`</summary>
<pre><code>use celmec::{impulse, two_body};
use ndarray::{array, Array1, Array2};
use std::f64::consts::PI;
use std::fs::File;
use std::io::Write;

fn main() {
    let mu: f64 = two_body::calculate_mu(5.972e24, 5.0e2);
    let a: f64 = 8.0e5 + 6.378e6;
    let period: f64 = two_body::calculate_period(mu, a);
    let rr0: Array1&lt;f64&gt; = array![a, 0., 0.];
    let vv0: Array1&lt;f64&gt; = array![0., 2. * a * PI / period, 0.];
    let system =
        two_body::create_two_body_system(0., 3. * period, 99, mu, rr0.clone(), vv0.clone());
    let impulse: Array2&lt;f64&gt; = array![[period], [0.], [1.2e3], [0.]];

    let orbit: Array2&lt;f64&gt; = impulse::calculate_impulse_effect(&amp;system.clone(), impulse);

    let mut coordinate_file = File::create(&quot;satellite.csv&quot;).unwrap();
    write!(coordinate_file, &quot;t,x,y,z,v_x,v_y,v_z\n&quot;).unwrap();
    for i in 0..orbit.dim().1 {
        write!(
            coordinate_file,
            &quot;{},{},{},{},{},{},{}\n&quot;,
            orbit[[0, i]],
            orbit[[1, i]],
            orbit[[2, i]],
            orbit[[3, i]],
            orbit[[4, i]],
            orbit[[5, i]],
            orbit[[6, i]]
        )
        .unwrap();
    }
}
</code></pre>
</details>
<h2 id="visualising-the-results-4"><a class="header" href="#visualising-the-results-4">Visualising the results</a></h2>
<p>As before, run <code>cargo run</code> to obtain a file called <code>satellite.csv</code> with the simulated orbit in it. To visualise the results, a python script called <code>plot_impulsed_orbit.py</code> is created:</p>
<details>
  <summary>`plot_impulsed_orbit.py` </summary>
<pre><code>import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;satellite.csv&quot;)

def plot_orbit(i):
    if i &lt; 33:
        plt.plot(df.x[0:i], df.y[0:i], 'r')
    else:
        plt.plot(df.x[0:34], df.y[0:34], 'r')
        plt.plot(df.x[33:i], df.y[33:i], 'b')

def main():
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn)
    ax.set_xlabel(&quot;x&quot;)
    ax.set_ylabel(&quot;y&quot;)
    ax.set_xlim([1.1*np.min(df.x), 1.1*np.max(df.x)])
    ax.set_ylim([1.1*np.min(df.y), 1.1*np.max(df.y)])
    anim = FuncAnimation(fig, plot_orbit, frames=101, repeat=False)

    f = r&quot;satellite.gif&quot;
    writergif = PillowWriter(fps=20)
    anim.save(f, writer=writergif)

    plt.show()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</details>
<p>and run with <code>python plot_impulsed_orbit.py</code>. It should produce a graph like this one:</p>
<p><img src="images/impulse.png" alt="Satellite orbit before and after impulse" /></p>
<p>For clarity, the orbit before the impulse is colored red and the orbit after applying the impulse is colored blue. The impulse has transformed the previously circular orbit into an ellipsis whose periapsis has remained at the point where the impulse was applied. Because the orbit was initially on the xy-plane and and impulse along that plane kept it there, visualisation is only done on that plane. However, the Rust code writes the coordinates in all dimensions down, so if you feel like editing the impulse of the Rust code into something different, you'll have the necessary output from the code to do 3d-visualisations by editing the Python script.</p>
<p>There is also an animation <code>satellite.gif</code> which should look more or less like this:</p>
<details>
  <summary>Satellite impulse animated</summary>
<p><img src="images/satellite.gif" alt="Satellite impulse animated" /></p>
</details>
<h2 id="two-alternative-impulses"><a class="header" href="#two-alternative-impulses">Two alternative impulses</a></h2>
<p>For the sake of a bit of fun let's try two edits to the <code>impulse</code> in the Rust code.</p>
<p>Firstly, let's keep the impulse's direction but triple its magnitude:</p>
<pre><code>    let impulse: Array2&lt;f64&gt; = array![[period], [0.], [3. * 1.2e3], [0.]];

</code></pre>
<p>Then <code>cargo run</code> and <code>python plot_impulsed_orbit.py</code> should produce this visualisation:</p>
<p><img src="images/hyperbolic_impulse.png" alt="Impulse craeting a hyperbolic trajactory" /></p>
<p>So this new impulse was big enough to throw the sateliite out of Earth's orbit into a hyperbolic trajectory.</p>
<p>Secondly, let's dip the the orbit into the z-direction:</p>
<pre><code>    let impulse: Array2&lt;f64&gt; = array![[period], [0.], [0.], [0.1 * 2. * a * PI / period]];
</code></pre>
<p>Now we can generate a 3d graph with a modified Python script:</p>
<details>
	<summary>The modified Python script for 3d graph</summary>
<pre><code>import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter

df=pd.read_csv(&quot;satellite.csv&quot;)

def plot_orbit(i):
    if i &lt; 33:
        plt.plot(df.x[0:i], df.y[0:i], df.z[0:i], 'r')
    else:
        plt.plot(df.x[0:34], df.y[0:34], df.z[0:34], 'r')
        plt.plot(df.x[33:i], df.y[33:i], df.z[33:i], 'b')

def main():
    fig = plt.figure()
    plotn=111
    ax = fig.add_subplot(plotn, projection='3d')
    ax.set_xlabel(&quot;x&quot;)
    ax.set_ylabel(&quot;y&quot;)
    ax.set_ylabel(&quot;z&quot;)
    ax.set_xlim([1.1*np.min(df.x), 1.1*np.max(df.x)])
    ax.set_ylim([1.1*np.min(df.y), 1.1*np.max(df.y)])
    ax.set_zlim([1.1*np.min(df.z), 1.1*np.max(df.z)])
    anim = FuncAnimation(fig, plot_orbit, frames=101, repeat=False)

    f = r&quot;satellite.gif&quot;
    writergif = PillowWriter(fps=20)
    anim.save(f, writer=writergif)

    plt.show()

if __name__ == &quot;__main__&quot;:
    main()
</code></pre>
</details>
<p>Now a <code>cargo run</code> and <code>python plot_impulsed_orbit.py</code> should generate an image like:</p>
<p><img src="images/3d_impulse.png" alt="Impulse in z-direction" /></p>
<p>Looking at the point of the impulse in more detail, we see that the first orbit does not quite close, even though the impulse happens when the first period completes. This is because, the impulse point does not match any simulation point and thus there is a &quot;discontinuous&quot; jump between the last simulation point of the un-impulsed orbit and the first simulation point of the impulsed points. 
<img src="images/3d_impulse_detail.png" alt="3d impulse detail" /></p>
<p>The next subchapter deals with the implementation details of the impulse and explains how to match the simulation and impulse points. But before that, here is the animated version of the 3d orbit toconclude this section:</p>
<details>
	<summary>Impulse in the z-direction animated</summary>
<p><img src="images/3d_impulse.gif" alt="Impulse in z-direction animated" /></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="impulse-implementation-details"><a class="header" href="#impulse-implementation-details">Impulse: Implementation Details</a></h1>
<p><code>Celmec</code> simulations are done from a starting time to an ending time for a given number of equidistanced steps. We can start from eg. time 0, end at time 3 and have 4 steps. A step represents a time point for which we simulate so the starting and ending times are the first and the last steps, respectively. Therefore, for the 4-step simulation time of the example, the steps are 0, 1, 2 and 3.</p>
<p align="center">
  <img src="images/steps.png" />
</p>
<p>An impulse can happen at any time between start and end time (including the endpoints themselves) and these times may or may not coincide with the steps.</p>
<p>Let's consider what happens when impulse point coincide with step. In this case, a simulation is done up to step before the impulse happens. Then, a transient simulation (in the sense that no results from this simulation are returned) is done from the latest simulated step to the impulse point, after which the impulse is applied. As the impulse point coincides with a step, we can then proceed with the simulation starting from that step but with a velocity modified by the impulse.</p>
<p>Say, that the impulse happens at time 2 in our 4-step example. In that case, a simulation would first run through steps 0 and 1. After that, a transient simulation is done for step 2 using simulation resuslt from step 1 as initial conditions. Then, the impulse is applied to the simulation results at step 2 from the transient simulation. Then the simulation results from step 2 with the impulse applied are used as initial conditions to simulate steps 2 and 3.</p>
<p align="center">
  <img src="images/impulse_at_step.png" />
</p>
<p>In case the impulse falls between two steps, the process is as follows. First, simulation is done up until the last step before the impulse. Then a transient simulation is done from the lest simulation point to the impulse point. The impulse is applied on the result of the transient simulation at the impulse point. Another transient simulation is carried out starting from the impulse point with the results of the previous transient simulation and the impulse application as the initial conditions. With these initial conditions, the next step is transiently simulated and the results are then used as initial conditions for a simulation from that step onward (including the step itself).</p>
<p>To use the previous 4-step example again, say the impulse happens at time 1.5. In this case a simulation is first done for steps 0 and 1. Then the first transient simulation is done from 1 to 1.5 and the impulse is then applied at the latter point. Using the result of the transient simulation and the application of the impulse as the initial conditions at 1.5, another transient simulation is carried for step 2. The results of this simulation are then set as initial conditions using which steps2 and 3 are simulated.</p>
<p align="center">
  <img src="images/impulse_between_steps.png" />
</p>
<h2 id="giving-a-continuous-impulse"><a class="header" href="#giving-a-continuous-impulse">Giving a &quot;Continuous&quot; Impulse</a></h2>
<p>With the information above, we can adjust the example at the end of the previous chapter to match the impulse to a simulation point. In the example, we were simulating for a total of three times the period of the original orbit with 99 points. To match the impulse at the time corresponding one orbit period, let's change the number of simulated points to 100.</p>
<p>Here is why this works: say we simulated for only one period instead of three and had 34 simulation points. Then we would start at the position at the starting time, have 32 steps on the orbit and then our last 34th (starting step + the 32 intermediary steps + 1) step on the starting position again (because after one period, the position is same as at the starting time). So we have 33 distinct positions on the orbit and on hte 34th step we hit the initial position again. Now switch to a total simulation time of 3 periods with 100: for each period we would have 33 distinct positions and then on the 34th step since the start of the period we would hit the initial positions again (ie. on 34th and 67th step counting from the very beginning). Spaving our steps in such a manner, we are guarantted to match step 34 to the period. However, at step 99 we would be a have our 33 distinct positions hit 3 times, but we would need to add an extra step that returns to the initial position at time 3 times the period. And hence we have a grand total of 100 steps.</p>
<p>By modifying the version of the Rust code of the previous section with an impulse in the z-direction by adding a simulation point:</p>
<pre><code>    let system = two_body::create_two_body_system(0., period, 100, mu, rr0.clone(), vv0.clone());
</code></pre>
<p>We get the following graph</p>
<p><img src="images/3d_impulse_cont.png" alt="Smoother z-directional impulse" /></p>
<p>For some reason the impulse point does not still not look as smooth as expected, but I'd argue it's already smoother than previously:</p>
<p><img src="images/3d_impulse_cont_detail.png" alt="Detail of smoother z-directional impulse" /></p>
<p>Again, a nice animated version to end with:</p>
<details>
	<summary>Continuous z-directional impulse animated</summary>
<p><img src="images/3d_impulse_cont.gif" alt="Smoother z-directional impulse animated" /></p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary-of-terms"><a class="header" href="#glossary-of-terms">Glossary of Terms</a></h1>
<p>This a list of abbreviations that celmec aims to use:</p>
<pre><code>a - semi-major axis
ee - vector pointing towards the perihelion
e - eccentricity (euclidean norm of ee)
f - true anomaly
G - gravitational constant
h - energy integral (freely translated from Finnish 'energiaintegraali' used in Johdatus Taivaanmekaniikkaan by Karttunen, 2020)
kk - angular momentum vector
k - angular momentum scalar (euclidean norm of kk)
m - mass
n - average angular velocity
rr - position vector
r - distance (euclidean norm of rr)
vv - velocity vector
v - velocity (euclidean norm of vv)
t - time
theta - polar angle (spherical coordinates)
iota - inclination
tau - perihelion time
phi - azimuthal angle (spherical coordinates)
omega - argument of periapsis
</code></pre>
<p>Note in the above, that when same letter is usually used for a scalar and a vector, the letter is doubled for the vector in the code.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
